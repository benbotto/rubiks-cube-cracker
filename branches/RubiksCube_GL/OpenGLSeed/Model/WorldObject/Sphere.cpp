#include "Sphere.h"

namespace busybin
{
  /**
   * Initialize the Sphere's vertices.
   * @param radius The radius of the Sphere.
   * @param pProgram The currently installed shader program.
   * @param pMatrixStack The World's MatrixStack.
   * @name The name of the Sphere.
   * @param numTriangleStrips The number of horizontal triangle strips.  This
   * number should be even.  If odd, it is rounded down.  The number should
   * also be greater than 3.  If not, it will be set to 4.
   * @param colors Two colors for stripes (see WorldObject).
   */
  Sphere::Sphere(float radius, Program* pProgram, MatrixStack* pMatrixStack,
    const string& name, unsigned numTriangleStrips, vector<vec4> colors) : 
    WorldObject(name, pProgram, pMatrixStack)
  {
    vector<vec3> vertBuf;
    vector<vec4> colorBuf;
    vector<vec4> colorToggle;

    // Basic initialization.
    this->radius = radius;

    if (numTriangleStrips % 2 == 1)
      this->numTriangleStrips = numTriangleStrips - 1;
    else
      this->numTriangleStrips = numTriangleStrips;

    if (numTriangleStrips < 4)
      this->numTriangleStrips = 4;

    // Make sure there are two colors for striping.
    this->setColors(colors, 2);
    colorToggle.reserve(2);
    colorToggle.push_back(colors.at(0));
    colorToggle.push_back(colors.at(1));

    // Create a quarter dome.
    buildQuarterDome(vertBuf, colorBuf);
    this->colors.clear();

    /*
     * Build the sphere out of 8 quarter domes.  The first 4 quarter domes are
     * rotated about the Y axis.  The second 4 are rotated about the Z axis
     * and the Y axis.
     */

    // Reserve space for the vertices and colors.
    this->vertices.reserve(vertBuf.size()  * 8);
    this->colors.reserve(colorBuf.size()   * 8);

    for (int dome = 0; dome < 2; ++dome)
    {
      vec3 zAxis(0.0f, 0.0f, 1.0f);
      mat4 rotationZ = rotate(mat4(1.0f), pi<float>() * dome, zAxis);

      for (int i = 0; i < 4; ++i)
      {
        vec3 yAxis(0.0f, 1.0f,   0.0f);
        mat4 rotationY = rotate(mat4(1.0f), half_pi<float>() * i, yAxis);

        for (vector<vec3>::iterator it = vertBuf.begin(); it != vertBuf.end(); ++it)
          this->vertices.push_back(vec3(rotationZ * rotationY * vec4(*it, 1.0f)));
      }
    }

    // Duplicate the colors.  The first 4 quarter domes have identical colors.
    for (int i = 0; i < 4; ++i)
      copy(colorBuf.begin(), colorBuf.end(), back_inserter(this->colors));

    // The bottom 4 quarter domes have inverse colors (otherwise the color at
    // the equator would be repeated).
    transform(this->colors.begin(),
      this->colors.end(),
      back_inserter(this->colors),
      Inverter<vec4>(colorToggle.at(0), colorToggle.at(1)));

    // Compute the normals for each vertex.
    this->computeVertexNormals();

    // Set up and fill the vertex buffer, color buffer, and normal buffer.
    this->getProgram()->createAndFillBuffer(this->vertices,
      this->getProgram()->getVertexPositionAttr(), this->getVAO());
    this->getProgram()->createAndFillBuffer(this->vertexNormals,
      this->getProgram()->getVertexNormalAttr(), this->getVAO());
    this->getProgram()->createAndFillBuffer(this->colors,
      this->getProgram()->getVertexColorAttr(), this->getVAO());
  }

  /**
   * Build all the vertices of a quarter dome.
   * @param vertBuf Filled with the vertices of the quarter dome.
   * @param colorBuf Filled with colors, one for each vertex.
   */
  void Sphere::buildQuarterDome(vector<vec3>& vertBuf,
    vector<vec4>& colorBuf)
  {
    vec3 zAxis(0.0f, 0.0f,         1.0f);
    vec3 yAxis(0.0f, 1.0f,         0.0f);
    vec3 start(0.0f, this->radius, 0.0f);
    vector<vector<vec3> > holdVerts;
    vector<vec4>          colorToggle;
    int                   toggle = 0;
    unsigned              numTriangleStrips = this->numTriangleStrips / 2;

    holdVerts.reserve(numTriangleStrips + 1);

    /* 
     * This works by generating a large triangle composed of numTriangleStrips
     * number of triangle strips.  A "large triangle" with numTriangleStrips = 2
     * would look like this.
     *
     *          /\
     *         /__\
     *        /\  /\
     *       /__\/__\
     * 
     * The vertices are generated by starting at point 0,1,0, and rotating
     * 90 degrees around the z axis numTriangleStrips + 1 times.  For each
     * iteration, vertices are generated by rotating 90 degrees about the y
     * axis.
     */
    for (unsigned level = 0; level < numTriangleStrips + 1; ++level)
    {
      float     angleZ    = half_pi<float>() / numTriangleStrips * level;
      mat4 rotationZ      = rotate(mat4(1.0f), angleZ, zAxis);
      unsigned  vertsThisLevel = level + 1;

      holdVerts.push_back(vector<vec3>());
      holdVerts.back().reserve(vertsThisLevel);

      for (unsigned v = 0; v < vertsThisLevel; ++v)
      {
        float     angleY    =  (vertsThisLevel == 1) ? 0 : half_pi<float>() / (vertsThisLevel - 1) * v;
        mat4 rotationY = rotate(mat4(1.0f), angleY, yAxis);

        holdVerts.back().push_back(
          vec3(rotationY * rotationZ * vec4(start, 1.0f)));
      }
    }

    // Initialize the colors.
    colorToggle.reserve(2);
    colorToggle.push_back(this->colors.at(0));
    colorToggle.push_back(this->colors.at(1));

    // Make sure the buffers are empty, and large enough.  There will be
    // numTriangleStrips ^ 2 * 2 vertices/colors.
    colorBuf.clear();
    vertBuf.clear();
    vertBuf.reserve(numTriangleStrips  * numTriangleStrips * 2);
    colorBuf.reserve(numTriangleStrips * numTriangleStrips * 2);

    /* From the vertices generated above, create a series of triangles that
     * can be used to draw the quarter dome.
     *
     *               |Level|Triangles
     *               |-----|---------
     *       0       |  0  |
     *      / \      |     |
     *     0---1     |  1  | [0,1,0 UP]
     *    / \ / \    |     |
     *   0---1---2   |  2  | [0,1,0 UP] [1,2,1 UP] [0,1,1 DOWN]
     *  / \ / \ / \  |     |
     * 0---1---2---3 |  3  | [0,1,0 UP] [1,2,1 UP] [2,3,2 UP] [0,1,1 DOWN] [1,2,2 DOWN]
     *
     */
    for (unsigned level = 1; level < holdVerts.size(); ++level)
    {
      unsigned numUp   = level;
      unsigned numDown = level - 1;

      colorBuf.resize(colorBuf.size() + (numUp + numDown) * 3, colorToggle.at(toggle));
      toggle ^= 1;

      // The vertices are pushed clock-wise for vertex normal computation.
      for (unsigned u = 0; u < numUp; ++u)
      {
        vertBuf.push_back(holdVerts.at(level).at(u));
        vertBuf.push_back(holdVerts.at(level - 1).at(u));
        vertBuf.push_back(holdVerts.at(level).at(u + 1));
      }

      for (unsigned d = 0; d < numDown; ++d)
      {
        vertBuf.push_back(holdVerts.at(level - 1).at(d));
        vertBuf.push_back(holdVerts.at(level - 1).at(d + 1));
        vertBuf.push_back(holdVerts.at(level).at(d + 1));
      }
    }
  }
}

